# TinyEngine

## Tree Growth Model
This was a small idea I had to grow trees, but it didn't really constitute its own repository. Since I built it with TinyEngine in about 6 hours, I decided to include it as an example program here.

This was based off of an observation I had while walking in the forest, that when a tree branch splits, it seems the sum of the cross-section of the two branches it splits into is conserved.

This program allows you to do that and also relax that rule to give a more general plant growth model. This is explained below.

The model is capable of growing different shapes of trees, from deciduous to evergreen. Some example screenshots are shown below.

![Example Tree Growth](https://github.com/weigert/TinyEngine/blob/master/examples/6_Tree/screenshots/Redtree.png)

![Example Growth 2](https://github.com/weigert/TinyEngine/blob/master/examples/6_Tree/screenshots/Yellowtree.png)

### How it Works
Every tree segment is a "branch". Every branch has a depth on the tree (higher depth, further along the tree). When a branch reaches a certain size (`splitsize`), it splits into two sub-branches. A branch that hasn't split yet is considered to have a leaf at the end. Branches with higher depth require a lower size to split again. This is computed using an exponential decay, parameterized by the `splitdecay` parameter using the branch's depth.

When a branch splits, it splits according to a split ratio X (`ratio`), so the two sub-branches can be evenly or unevenly sized. One branch grows proportional to X, the other to (1-X), leading to the size-conservation effect that is desired.

The tree is "fed" at a certain rate every time-step. This constant feed is passed down the tree. Every branch it touches takes a fraction of the feed (`passratio`) and uses it to grow itself. It then passes the rest to its sub-branches according to the split ratio. This process repeats until the feed is used up.

The pass ratio strictly determines how the branch properties are conserved. Using an arbitrary pass-ratio, the branch scales will remain proportional (because of the split ratio), but not exactly proportional according to the cross-sectional area, the radius, or some other quantity.

To conserve a quantity we can apply feedback-control. For instance, to control for conserved cross-sectional area the pass-ratio at every branching needs to be set according to:

        pass = 1.0 - (A->area + B->area) / (A->area + B->area + area);

Where A and B are the child branches. Similarly to conserve radius.

Sometimes nice results can be produced while not conserving the cross-sectional area, particularly for branches of small size. Very nice little bushes can be generated by using a constant pass-ratio instead of a size-conserving, continuously adjusted one. In this program, you can do both.

Branches that haven't split yet grow in length and radius, branches that have split only grow in radius.

Branches also have a direction property. The direction of each branch is computed as a weighted sum between the parent branches direction and a random normal vector to the parent branch. The weight is given by the split ratio, so that thicker child branches are more likely to grow straight, and small ones are more likely to grow perpendicular. Additionally, a `spread` parameter adds extra weight to the normal vector if desired so that branches tend more outwards or straight. A random normal vector can be computed by taking a random vector in 3D space and computing the cross product.

All of these properties can be controlled directly from the control panel.

#### Parameters

        Growth Rate - Rate of Tree Feeding
        Split Ratio - Value of X when a branch splits (how lopsided is the split)
        Pass Ratio - How much of the feed does a branch consume vs. pass on
        Branch Spread - How much do branches prefer to grow perpendicular vs. straight
        Split Size - Critical size when a branch stops being a leaf node and splits

Note that these parameters are currently fixed, but could potentially be sampled from distributions instead (e.g. normal distribution around a mean) to give more realism.

This is merely an approximation of reality, and isn't entirely realistic. Other possible improvements could be:

        - Growth only in girth, not length
        - More than single splits
        - Dynamic Properties
          - Dependency on the current branch number
          - Different Branch Types spawning different branch types
        - Actual Leaf Growth
        - More intelligent choice of growth direction based on a simple rule

### Visualization
The leaves are a particle system. They use the image `leaf.png`, and they always face the camera. You can alter color, opacity, size and spread (you can have multiple leaves around a branch).

The tree is meshed by a bunch of cylinders that correspond to the branches. A few parameters then make it look nice (for instance a taper, the scaling of length and width).

All colors can be edited. Optionally, a wire-mesh can be displayed on top. Leaves and the tree itself can be turned off.

Note that in order to make sure the leaf positions are randomized but don't change every frame, their position offset is hashed. This is done by giving every branch a random ID (which stays the same every tick), which can be used to hash the leaves position offset. This allows for generating a particle cloud that doesn't change all the time and stays fixed in 3D space.

A leaf will only show on a leaf-branch that has some minimum depth in the tree.

#### Reading

The model itself is implemented in `tree.h`. Here you will also find how the mesh for the tree and particle system for the leaves are generated.

To see how the interface and event handler are made, read `model.h`.

Everything is wrapped in `main.cpp`.

Overall the code to generate the trees is very brief.

### Usage

Compile with make

    make all

Control Panel:

    Toggle Pause - P
    Toggle Auto-Rotate - A
    Toggle Control Panel - ESC
    Regrow Tree - R
